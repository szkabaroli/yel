//! Rust code generation from LIR.

use crate::context::CompilerContext;
use crate::hir::expr::{BinOp, HirLiteral, UnaryOp};
use crate::lir::{
    LirComponent, LirEffect, LirExpr, LirExprKind, LirHandler, LirNode, LirNodeKind, LirSignal,
};
use crate::lir::expr::LirStatement;
use crate::lir::signal::UpdateKind;
use crate::types::{InternedTyKind, Ty};

/// Generate Rust code from a LIR component.
pub fn generate_rust(component: &LirComponent, ctx: &CompilerContext) -> String {
    let mut codegen = RustCodegen::new(ctx);
    codegen.generate_component(component)
}

/// Rust code generator.
struct RustCodegen<'ctx> {
    ctx: &'ctx CompilerContext,
    output: String,
    indent: usize,
}

impl<'ctx> RustCodegen<'ctx> {
    fn new(ctx: &'ctx CompilerContext) -> Self {
        Self {
            ctx,
            output: String::new(),
            indent: 0,
        }
    }

    #[allow(dead_code)]
    fn emit(&mut self, s: &str) {
        self.output.push_str(s);
    }

    fn emit_line(&mut self, s: &str) {
        for _ in 0..self.indent {
            self.output.push_str("    ");
        }
        self.output.push_str(s);
        self.output.push('\n');
    }

    fn emit_newline(&mut self) {
        self.output.push('\n');
    }

    // ========================================================================
    // Component Generation
    // ========================================================================

    fn generate_component(&mut self, component: &LirComponent) -> String {
        let name = self.ctx.str(component.name);

        self.emit_line("// Generated by yelc");
        self.emit_line("#![allow(dead_code, unused_variables)]");
        self.emit_newline();

        // Generate struct
        self.generate_struct(&name, &component.signals);
        self.emit_newline();

        // Generate impl
        self.emit_line(&format!("impl {} {{", name));
        self.indent += 1;

        // Constructor
        self.generate_constructor(&component.signals);
        self.emit_newline();

        // Render method
        self.generate_render_method(component);
        self.emit_newline();

        // Effect update methods
        self.generate_effect_methods(&component.effects);

        self.indent -= 1;
        self.emit_line("}");

        std::mem::take(&mut self.output)
    }

    fn generate_struct(&mut self, name: &str, signals: &[LirSignal]) {
        self.emit_line(&format!("pub struct {} {{", name));
        self.indent += 1;

        for signal in signals {
            let signal_name = self.ctx.str(self.ctx.defs.name(signal.def_id));
            let ty_str = self.emit_type(signal.ty);
            self.emit_line(&format!("pub {}: {},", signal_name, ty_str));
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    fn generate_constructor(&mut self, signals: &[LirSignal]) {
        self.emit_line("pub fn new() -> Self {");
        self.indent += 1;
        self.emit_line("Self {");
        self.indent += 1;

        for signal in signals {
            let signal_name = self.ctx.str(self.ctx.defs.name(signal.def_id));
            if let Some(default) = &signal.default {
                let default_str = self.emit_expr(default);
                self.emit_line(&format!("{}: {},", signal_name, default_str));
            } else {
                self.emit_line(&format!("{}: Default::default(),", signal_name));
            }
        }

        self.indent -= 1;
        self.emit_line("}");
        self.indent -= 1;
        self.emit_line("}");
    }

    fn generate_render_method(&mut self, component: &LirComponent) {
        self.emit_line("pub fn render(&self) -> Node {");
        self.indent += 1;

        if component.body.is_empty() {
            self.emit_line("Node::empty()");
        } else if component.body.len() == 1 {
            let node_code = self.emit_node(&component.body[0]);
            self.emit_line(&node_code);
        } else {
            self.emit_line("Node::fragment(vec![");
            self.indent += 1;
            for node in &component.body {
                let node_code = self.emit_node(node);
                self.emit_line(&format!("{},", node_code));
            }
            self.indent -= 1;
            self.emit_line("])");
        }

        self.indent -= 1;
        self.emit_line("}");
    }

    fn generate_effect_methods(&mut self, effects: &[LirEffect]) {
        for effect in effects {
            self.generate_effect_method(effect);
            self.emit_newline();
        }
    }

    fn generate_effect_method(&mut self, effect: &LirEffect) {
        let method_name = format!("update_effect_{}", effect.id);
        let update_kind_str = match &effect.update_kind {
            UpdateKind::Property(name) => format!("property \"{}\"", name),
            UpdateKind::TextContent => "text content".to_string(),
            UpdateKind::Class(name) => format!("class \"{}\"", name),
            UpdateKind::Style(name) => format!("style \"{}\"", name),
        };

        self.emit_line(&format!("/// Update {} on node {:?}", update_kind_str, effect.target_node));
        self.emit_line(&format!("fn {}(&self) -> impl std::fmt::Display {{", method_name));
        self.indent += 1;

        let expr_str = self.emit_expr(&effect.expr);
        self.emit_line(&expr_str);

        self.indent -= 1;
        self.emit_line("}");
    }

    // ========================================================================
    // Node Generation
    // ========================================================================

    fn emit_node(&self, node: &LirNode) -> String {
        match &node.kind {
            LirNodeKind::Element {
                component: _,
                tag,
                static_bindings,
                dynamic_binding_ids: _,
                handlers,
                children,
            } => {
                let mut parts = Vec::new();
                parts.push(format!("Node::element(\"{}\")", tag));

                // Static bindings
                for binding in static_bindings {
                    let value = self.emit_expr(&binding.value);
                    parts.push(format!(".attr(\"{}\", {})", binding.name, value));
                }

                // Event handlers
                for handler in handlers {
                    let handler_code = self.emit_handler(handler);
                    parts.push(format!(".on(\"{}\", {})", handler.event, handler_code));
                }

                // Children
                if !children.is_empty() {
                    let children_code: Vec<_> = children.iter().map(|c| self.emit_node(c)).collect();
                    parts.push(format!(".children(vec![{}])", children_code.join(", ")));
                }

                parts.join("")
            }
            LirNodeKind::StaticText(text) => {
                format!("Node::text({:?})", text)
            }
            LirNodeKind::DynamicText { effect_id } => {
                format!("Node::dynamic_text(self.update_effect_{}())", effect_id)
            }
            LirNodeKind::If {
                condition,
                then_branch,
                else_if_branches,
                else_branch,
            } => {
                let cond = self.emit_expr(condition);
                let then_nodes: Vec<_> = then_branch.iter().map(|n| self.emit_node(n)).collect();

                let mut code = format!(
                    "if {} {{ Node::fragment(vec![{}]) }}",
                    cond,
                    then_nodes.join(", ")
                );

                for (else_cond, else_nodes) in else_if_branches {
                    let else_cond_str = self.emit_expr(else_cond);
                    let nodes: Vec<_> = else_nodes.iter().map(|n| self.emit_node(n)).collect();
                    code.push_str(&format!(
                        " else if {} {{ Node::fragment(vec![{}]) }}",
                        else_cond_str,
                        nodes.join(", ")
                    ));
                }

                if let Some(else_nodes) = else_branch {
                    let nodes: Vec<_> = else_nodes.iter().map(|n| self.emit_node(n)).collect();
                    code.push_str(&format!(
                        " else {{ Node::fragment(vec![{}]) }}",
                        nodes.join(", ")
                    ));
                } else {
                    code.push_str(" else { Node::empty() }");
                }

                code
            }
            LirNodeKind::For {
                item: _,
                item_name,
                item_span: _,
                item_ty: _,
                iterable,
                key,
                body,
            } => {
                let item_ident = self.ctx.str(*item_name);
                let iterable_code = self.emit_expr(iterable);
                let body_nodes: Vec<_> = body.iter().map(|n| self.emit_node(n)).collect();

                let key_code = key
                    .as_ref()
                    .map(|k| format!(", |{}| {}", item_ident, self.emit_expr(k)))
                    .unwrap_or_default();

                format!(
                    "Node::for_each({}, |{}| Node::fragment(vec![{}]){})",
                    iterable_code,
                    item_ident,
                    body_nodes.join(", "),
                    key_code
                )
            }
        }
    }

    fn emit_handler(&self, handler: &LirHandler) -> String {
        let statements: Vec<_> = handler.body.iter().map(|s| self.emit_statement(s)).collect();
        format!("|_event| {{ {} }}", statements.join(" "))
    }

    // ========================================================================
    // Expression Generation
    // ========================================================================

    fn emit_expr(&self, expr: &LirExpr) -> String {
        match &expr.kind {
            LirExprKind::Local(local_id) => {
                format!("local_{}", local_id.0)
            }
            LirExprKind::Def(def_id) => {
                let name = self.ctx.defs.name(*def_id);
                format!("self.{}", self.ctx.str(name))
            }
            LirExprKind::Literal(lit) => self.emit_literal(lit),
            LirExprKind::Binary { op, lhs, rhs } => {
                let lhs_str = self.emit_expr(lhs);
                let rhs_str = self.emit_expr(rhs);
                let op_str = self.emit_binop(*op);
                format!("({} {} {})", lhs_str, op_str, rhs_str)
            }
            LirExprKind::Unary { op, operand } => {
                let operand_str = self.emit_expr(operand);
                let op_str = self.emit_unaryop(*op);
                format!("({}{})", op_str, operand_str)
            }
            LirExprKind::Field { base, field_idx } => {
                let base_str = self.emit_expr(base);
                format!("{}.{}", base_str, field_idx.0)
            }
            LirExprKind::Index { base, index } => {
                let base_str = self.emit_expr(base);
                let index_str = self.emit_expr(index);
                format!("{}[{}]", base_str, index_str)
            }
            LirExprKind::Call { func, args } => {
                let args_str: Vec<_> = args.iter().map(|a| self.emit_expr(a)).collect();
                let func_name = self.ctx.str(self.ctx.defs.name(*func));

                // Handle known builtin functions by name
                match func_name.as_str() {
                    "concat" => {
                        // concat -> format! with {} placeholders
                        format!("format!(\"{}\"{})",
                            "{}".repeat(args.len()),
                            args_str.iter().map(|p| format!(", {}", p)).collect::<String>()
                        )
                    }
                    "bool-to-string" | "s32-to-string" | "u32-to-string"
                    | "f32-to-string" | "f64-to-string" | "char-to-string" => {
                        // Type-specific conversions -> Rust's .to_string()
                        format!("{}.to_string()", args_str.first().unwrap_or(&"".to_string()))
                    }
                    "object-to-string" => {
                        // Complex type conversion -> return "[object]" literal
                        "\"[object]\".to_string()".to_string()
                    }
                    "len" => {
                        // len -> .len()
                        format!("{}.len()", args_str.first().unwrap_or(&"".to_string()))
                    }
                    _ => {
                        // Regular function call
                        format!("self.{}({})", func_name, args_str.join(", "))
                    }
                }
            }
            LirExprKind::SignalRead(def_id) => {
                let name = self.ctx.defs.name(*def_id);
                format!("self.{}", self.ctx.str(name))
            }
            LirExprKind::Ternary {
                condition,
                then_expr,
                else_expr,
            } => {
                let cond = self.emit_expr(condition);
                let then_str = self.emit_expr(then_expr);
                let else_str = self.emit_expr(else_expr);
                format!("if {} {{ {} }} else {{ {} }}", cond, then_str, else_str)
            }
            LirExprKind::EnumCase { ty_def, discriminant } => {
                // Get enum type name and case name
                let enum_name = self.ctx.str(self.ctx.defs.name(*ty_def));
                // For now, use discriminant index as placeholder
                format!("{}::Case{}", enum_name, discriminant)
            }
            LirExprKind::VariantCtor { ty_def, case_idx, payload } => {
                let variant_name = self.ctx.str(self.ctx.defs.name(*ty_def));
                let ctor = format!("{}::Case{}", variant_name, case_idx);
                if let Some(p) = payload {
                    format!("{}({})", ctor, self.emit_expr(p))
                } else {
                    ctor
                }
            }
        }
    }

    fn emit_literal(&self, lit: &HirLiteral) -> String {
        match lit {
            HirLiteral::Int(n) => n.to_string(),
            HirLiteral::Float(f) => {
                if f.fract() == 0.0 {
                    format!("{}.0", f)
                } else {
                    f.to_string()
                }
            }
            HirLiteral::String(s) => format!("{:?}", s),
            HirLiteral::Char(c) => format!("{:?}", c),
            HirLiteral::Bool(b) => b.to_string(),
            HirLiteral::Unit(value, unit) => {
                // Convert unit literals to appropriate values
                match unit.as_str() {
                    "px" => format!("{}f32", value),
                    "%" => format!("{}f32 / 100.0", value),
                    "deg" => format!("{}f32 * std::f32::consts::PI / 180.0", value),
                    "rad" => format!("{}f32", value),
                    "ms" => format!("{}f32", value),
                    "s" => format!("{}f32 * 1000.0", value),
                    _ => format!("{}f32 /* {} */", value, unit),
                }
            }
            HirLiteral::Color(hex) => {
                // Parse #rrggbb or #rrggbbaa
                if hex.len() >= 7 {
                    let r = u8::from_str_radix(&hex[1..3], 16).unwrap_or(0);
                    let g = u8::from_str_radix(&hex[3..5], 16).unwrap_or(0);
                    let b = u8::from_str_radix(&hex[5..7], 16).unwrap_or(0);
                    let a = if hex.len() >= 9 {
                        u8::from_str_radix(&hex[7..9], 16).unwrap_or(255)
                    } else {
                        255
                    };
                    format!("0x{:02x}{:02x}{:02x}{:02x}u32", a, r, g, b)
                } else {
                    format!("0x00000000u32 /* invalid color: {} */", hex)
                }
            }
            HirLiteral::List(items) => {
                let items_str: Vec<_> = items.iter().map(|i| self.emit_hir_expr_as_lir(i)).collect();
                format!("vec![{}]", items_str.join(", "))
            }
            HirLiteral::Tuple(items) => {
                let items_str: Vec<_> = items.iter().map(|i| self.emit_hir_expr_as_lir(i)).collect();
                format!("({})", items_str.join(", "))
            }
            HirLiteral::Record { fields } => {
                // We don't know the type name at this point, but we can emit the fields
                let fields_str: Vec<_> = fields
                    .iter()
                    .map(|(name, expr)| format!("{}: {}", name, self.emit_hir_expr_as_lir(expr)))
                    .collect();
                format!("{{ {} }}", fields_str.join(", "))
            }
        }
    }

    /// Fallback for HIR expressions embedded in literals (e.g., list items).
    fn emit_hir_expr_as_lir(&self, _expr: &crate::hir::expr::HirExpr) -> String {
        // In a complete implementation, we would lower HIR to LIR first
        // For now, we emit a placeholder
        "/* HIR expr */".to_string()
    }

    fn emit_binop(&self, op: BinOp) -> &'static str {
        match op {
            BinOp::Add => "+",
            BinOp::Sub => "-",
            BinOp::Mul => "*",
            BinOp::Div => "/",
            BinOp::Mod => "%",
            BinOp::Eq => "==",
            BinOp::Ne => "!=",
            BinOp::Lt => "<",
            BinOp::Le => "<=",
            BinOp::Gt => ">",
            BinOp::Ge => ">=",
            BinOp::And => "&&",
            BinOp::Or => "||",
            BinOp::BitAnd => "&",
            BinOp::BitOr => "|",
            BinOp::BitXor => "^",
        }
    }

    fn emit_unaryop(&self, op: UnaryOp) -> &'static str {
        match op {
            UnaryOp::Neg => "-",
            UnaryOp::Not => "!",
        }
    }

    // ========================================================================
    // Statement Generation
    // ========================================================================

    fn emit_statement(&self, stmt: &LirStatement) -> String {
        match stmt {
            LirStatement::Expr(expr) => {
                format!("{};", self.emit_expr(expr))
            }
            LirStatement::SignalWrite { signal, value } => {
                let signal_name = self.ctx.defs.name(*signal);
                let value_str = self.emit_expr(value);
                format!("self.{} = {};", self.ctx.str(signal_name), value_str)
            }
            LirStatement::If {
                condition,
                then_branch,
                else_branch,
            } => {
                let cond = self.emit_expr(condition);
                let then_stmts: Vec<_> = then_branch.iter().map(|s| self.emit_statement(s)).collect();

                let mut code = format!("if {} {{ {} }}", cond, then_stmts.join(" "));

                if let Some(else_stmts) = else_branch {
                    let else_code: Vec<_> = else_stmts.iter().map(|s| self.emit_statement(s)).collect();
                    code.push_str(&format!(" else {{ {} }}", else_code.join(" ")));
                }

                code
            }
        }
    }

    // ========================================================================
    // Type Emission
    // ========================================================================

    fn emit_type(&self, ty: Ty) -> String {
        match self.ctx.ty_kind(ty) {
            InternedTyKind::Bool => "bool".to_string(),
            InternedTyKind::S8 => "i8".to_string(),
            InternedTyKind::S16 => "i16".to_string(),
            InternedTyKind::S32 => "i32".to_string(),
            InternedTyKind::S64 => "i64".to_string(),
            InternedTyKind::U8 => "u8".to_string(),
            InternedTyKind::U16 => "u16".to_string(),
            InternedTyKind::U32 => "u32".to_string(),
            InternedTyKind::U64 => "u64".to_string(),
            InternedTyKind::F32 => "f32".to_string(),
            InternedTyKind::F64 => "f64".to_string(),
            InternedTyKind::Char => "char".to_string(),
            InternedTyKind::String => "String".to_string(),
            InternedTyKind::List(elem) => format!("Vec<{}>", self.emit_type(*elem)),
            InternedTyKind::Option(inner) => format!("Option<{}>", self.emit_type(*inner)),
            InternedTyKind::Result { ok, err } => {
                let ok_str = ok.map(|t| self.emit_type(t)).unwrap_or_else(|| "()".to_string());
                let err_str = err.map(|t| self.emit_type(t)).unwrap_or_else(|| "()".to_string());
                format!("Result<{}, {}>", ok_str, err_str)
            }
            InternedTyKind::Tuple(elems) => {
                let inner: Vec<_> = elems.iter().map(|e| self.emit_type(*e)).collect();
                format!("({})", inner.join(", "))
            }
            InternedTyKind::Adt(def_id) => {
                let name = self.ctx.defs.name(*def_id);
                self.ctx.str(name)
            }
            InternedTyKind::Func { params, ret } => {
                let param_strs: Vec<_> = params.iter().map(|p| self.emit_type(*p)).collect();
                let ret_str = ret.map(|r| self.emit_type(r)).unwrap_or_else(|| "()".to_string());
                format!("fn({}) -> {}", param_strs.join(", "), ret_str)
            }
            InternedTyKind::Length
            | InternedTyKind::PhysicalLength
            | InternedTyKind::Angle
            | InternedTyKind::Duration
            | InternedTyKind::Percent
            | InternedTyKind::RelativeFontSize => "f32".to_string(),
            InternedTyKind::Color | InternedTyKind::Brush => "u32".to_string(),
            InternedTyKind::Image => "String".to_string(),
            InternedTyKind::Easing => "String".to_string(),
            InternedTyKind::Error | InternedTyKind::Unknown => "()".to_string(),
            InternedTyKind::Unit => "()".to_string(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ids::DefId;
    use crate::source::{SourceId, Span};

    fn dummy_span() -> Span {
        Span::new(SourceId(0), 0, 0)
    }

    #[test]
    fn test_emit_basic_component() {
        let ctx = CompilerContext::new();

        let name = ctx.intern("Counter");
        let component = LirComponent {
            def_id: DefId(0),
            name,
            span: dummy_span(),
            is_export: true,
            signals: vec![],
            effects: vec![],
            body: vec![],
        };

        let code = generate_rust(&component, &ctx);
        assert!(code.contains("pub struct Counter"));
        assert!(code.contains("pub fn new()"));
        assert!(code.contains("pub fn render(&self)"));
    }

    #[test]
    fn test_emit_expression() {
        let ctx = CompilerContext::new();
        let codegen = RustCodegen::new(&ctx);

        // Test literal
        let expr = LirExpr::new(
            LirExprKind::Literal(HirLiteral::Int(42)),
            Ty::S32,
        );
        assert_eq!(codegen.emit_expr(&expr), "42");

        // Test binary
        let lhs = Box::new(LirExpr::new(LirExprKind::Literal(HirLiteral::Int(1)), Ty::S32));
        let rhs = Box::new(LirExpr::new(LirExprKind::Literal(HirLiteral::Int(2)), Ty::S32));
        let binary = LirExpr::new(
            LirExprKind::Binary { op: BinOp::Add, lhs, rhs },
            Ty::S32,
        );
        assert_eq!(codegen.emit_expr(&binary), "(1 + 2)");
    }

    #[test]
    fn test_emit_type() {
        let ctx = CompilerContext::new();
        let codegen = RustCodegen::new(&ctx);

        assert_eq!(codegen.emit_type(Ty::S32), "i32");
        assert_eq!(codegen.emit_type(Ty::BOOL), "bool");
        assert_eq!(codegen.emit_type(Ty::STRING), "String");
    }
}
